CREAR UN JUEGO DE ATRAPAR LA COMIDA EN C#, IMLEMENTANDO TODO LO VISTO Y UN SISTEMA DE ARCHIVOS.

EL JUEGO DEBERA CONTAR EN LA PARTE INERIOR CON UN PERSONAJE QUE PODRA SER MOVIDO HORIZONTALMENTE POR LA 
PANTALLA UTILIZANDO EL MOUSE. DE LA PARTE SUPERIOR DE LA PANTALLA CAERAN DIVERSOS OBJETOS, UNOS BUENOS
Y OTROS MALOS. CUANDO ATRAPAMOS UN OBJETO BUENO ANOTAMOS UN PUNTO. CUANDO ATRAPAMOS UN OBJETO MALO SE NOS SUMA UNO AL CONTADOR DE ERRORES. SI TENEMOS OCHO ERRORES, PERDEMOS EL JUEGO. PARA AUMENTAR LA DIFICULTAD,
A MEDIDA QUE PASA EL TIEMPO DEL JUEGO, EMPEZARAN A CAER MAS OBJETOS Y A UNA VELOCIDAD CADA VEZ MAS ALTA. HABRA UNA PROPORCION ENTRE LA CANTIDAD DE OBJETOS BUENOS Y OBJETOS MALOS QUE CAEN, DE MANERA QUE CAIGAN MAS BUENOS QUE MALOS. CUANDO SALE LA PANTALLA DE PERDER, SE DEBERAN MOSTRAR LOS PUNTOS CONSEGUIDOS Y EL PUNTAJE MAS ALTO OBTENIDO HASTA AHORA. SI EL PUNTAJE CONSEGUIDO EN ESTA PARTIDA ES EL MAS ALTO, INFORMARLO Y GUARDARLO EN UN ARCHIVO DE PROGRAMA. 

AL ABRIR EL PROGRAMA SE DEBERA MOSTRAR UNA PANTALLA DE BIENVENIDA CON LOS CREDITOS, Y "PULSE BARRA ESPACIADORA PARA EMPEZAR". TAMBIEN PODRIA CONTENER UN MENU QUE PERMITA ELEGIR LA ESTETICA DEL JUEGO, COMO EN MARIOCROSSOVER. TAMBIEN PODRIA AÑADIRSE LA OPCION DE PAUSAR EL JUEGO.

----------------------------------------------------------------

CON LA IDEA GENERAL DEFINIDA, PASEMOS A DISEÑAR LA LOGICA GENERAL Y MAS ESPECIFICA DEL JUEGO, PARA PASAR AL DISEÑO.

1-PANTALLA PRINCIPAL. SE MUESTRA LA PORTADA DEL JUEGO."PRESIONE BARRA ESPACIADORA PARA COMENZAR".

AL PRESIONAR, DEBE CAMBIAR EL FONDO.

AHORA EL CANVAS DEBE RESPONDER A EVENTOS DE MOUSE (MOUSE MOVE) O EVENTO DE TECLADO. EL PERSONAJE DEBERA MOVERSE A CIERTA VELOCIDAD, HASTA LLEGAR A LA X DONDE ESTA EL MOUSE O MOVERSE CON LAS TECLAS. ESTO SE CONTROLARA DESDE EL HILO PRINCIPAL.

LUEGO, CADA OBJETO QUE CAIGA TENDRA ASOCIADO UN HILO QUE CALCULARA SU POSICION CADA CIERTO TIEMPO. CUANDO UN OJETO SALE DE PANTALLA, ESE HILO "MUERE".

DESDE EL HILO PRINCIPAL TAMBIEN SE PODRIA CONTROLAR LA LOGICA DEL JUEGO (COLISIONES, PUNTAJE ETC).

Y POR ULTIMO HABRA UN HILO DEDICADO A ACTUALIZAR LOS GRAFICOS EN BASE A LOS DATOS OBTENIDOS DESDE EL HILO MAIN.

EN CASO DE PERDER, EL HILO MAIN DEBERA CAMBIAR EL ESTADO DEL JUEGO PARA QUE EL HILO DE LOS GRAFICOS MUESTRE LA PANTALLA DE GAMEOVER, JUNTO CON EL PUNTAJE Y DE SER NECESARIO, ALMACENAR EL PUNTAJE EN DISCO DURO.

----------------------------------------------------------------------------------------------------------

COSAS A INVESTIGAR:

1-COMO USAR IMAGENES----DONE

2-COMO USAR SONIDO

3-MOUSE EVENTS-----DONE

4-STREAMS EN C#

5-COMO CALCULAR FPS PARA TODAS LAS COMPUTADORAS, COMO IMPLEMENTAR UN GAMELOOP---DONE

6-DISEÑO DEL JUEGO

------------------------------------------

LA ESTRUCTURA DEL GAMELOOP SERA LA SIGUIENTE:

while (true)
{
  double start = getCurrentTime();
  processInput();
  update();
  render();

  sleep(start + MS_PER_FRAME - getCurrentTime());
}

PROCESSINPUT SE ENCARGARA DE ESTABLECER LA POSICION DE SAMUS SEGUN LA TECLA PRESIONADA.

UPDATE SE ENCARGARA DE LA LOGICA; LOS OBJETOS EN PANTALLA ESTARAN EN UN ARRAY, Y A CADA UNO SE LE ACTUALIZARA SU POSICION. EN BASE A SUS RESULTADOS, SE PODRA DAR UN OUTPUT DE GAMEOVER, RESTAR PUNTOS, SUMARLOS, ETC.

RENDER SE ENCARGARA DE DIBUJAR TODO EN LA PANTALLA, SEGUN CORRESPONDA.

LUEGO EL HILO DESCANSARA HASTA QUE PASEN LOS MILISEGUNDOS NECESARIOS PARA LLEGAR A LOS 60FPS.

----------------------------------------------------------------

CON EL HILO PRINCIPAL EN MENTE, ES HORA DE TRABAJAR EN LOS DISTINTOS OBJETOS QUE FORMARAN EL JUEGO.

TENEMOS: SAMUS,

OBJETOS BUENOS Y MALOS,

ERRORES

Y PUNTAJE.

TODOS ESTOS OBJETOS DEBERAN TENER SUS PROPIEDADES Y METODOS, QUE SE COMUNICARAN ENTRE SI FORMANDO LA LOGICA DEL JUEGO EN EL METODO UPDATE.

----------------CLASE SAMUS-------------------------------------

PROPIEDADES:X,DIRECCION

METODOS:POWER-UP(? POWER DOWN(?,MOVERSE

POWER-UP:DEBERA SUMARSE UN PUNTO,Y DESESPAWNEAR EL OBJETO.

POWER DOWN: DEBERA SUMARSE UN ERROR, Y DESESPAWNEAR EL OBJETO. EN CASO DE LLEGAR AL MAXIMO DE ERRORES, INVOCAR METODO GAMEOVER().

-----------CLASE OBJETOS------------

PROPIEDADES: VELOCIDAD,ESBUENO,ESMALO,X,Y,OBJETOS EN PANTALLA,IMAGEN(O REFERENCIA A UN CONTROL IMAGEN)

OBJETOS EN PANTALLA: LINKEDLIST FIJO CON EL MAXIMO DE OBJETOS QUE HAY EN PANTALLA.

METODOS:SPAWNOBJETO,CAER,DESPWNOBJETO

SPAWNOBJETO:CREARA UNA NUEVA INSTANCIA DE OBJETO, Y SU VELOCIDAD Y NATURALEZA QUEDARAN DETERMINADOS POR PROBABILIDADES. PARA CALCULAR ESTO SE TENDRA EN CUENTA LA CANTIDAD DE PUNTOS HECHOS EN PANTALLA Y LOS ESPACIOS DISPONIBLES. EL NUMERO DE VECES QUE SE LLAMA A ESTE METODO TAMBIEN ESTARA SUJETO A PROBABILIDADES.

DESPAWNOBJETO:ELIMINA LA INSTANCIA DE LA ESTRUCTURA DE DATOS. LOS CONTROLES IMAGEN SUJETOS TENDRAN WIDTH 0.

CAER:SEGUN LA VELOCIDAD, SE SUMA UN CIERTO VALOR AL Y DE ESTE OBJETO.

--------CLASE MAIN---------

PROPIEDADES:ERRORES Y PUNTAJE.

METODOS:PROCESSINPUT,UPDATE,RENDER,GAMEOVER.

EL MAIN LOOP DEBERA INICIARSE UNA VEZ PRESIONADA LA BARRA ESPACIADORA. EL JUEGO TIENE QUE ABRIRSE CON LA IMAGEN DE MENU, Y CUANDO SE PRESIONA LA BARRA, HACER EL WIDTH DE LA IMAGEN 0, Y CARGAR LAS NUEVAS IMAGENES, ADEMAS DE INICIAR EL MAIN LOOP.

GAMEOVER: DEBERAN BORRARSE TODAS LAS IMAGENES EN PANTALLA Y MOSTRAR UN NUEVO FONDO. SE DEBERA INFORMAR DEL PUNTAJE OBTENIDO, Y LEER DE DISCO EL MEJOR PUNTAJE GUARDADO. EN CASO DE SER ESTE EL MEJOR PUNTAJE, SE DEBERA INFORMAR Y ESCRIBIRLO EN DISCO TAMBIEN.

-----------------DISEÑO----------------------

LA VENTANA TENDRA ALTURA 900 Y ANCHO 800. SAMUS TENDRA UN ANCHO DE 100 PIXELES. LOS OBJETOS 80X80PIXELES.


